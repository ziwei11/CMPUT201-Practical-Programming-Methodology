/*
  CMPUT201W20 Final TEST DRIVER for ziwei11
  
  DO NOT CHANGE THIS FILE!
  
  DO NOT EDIT THIS FILE!
  
  DO NOT MODIFY THIS FILE!
  
  VERSION: 0.9.0
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "myfloat.h"

#define ASSERT_EQUAL(result, expect) soft_equal(\
    (result) == (expect), \
    #result, \
    #expect, \
    __FILE__, \
    __LINE__\
);

#define CHECK_BYTES 4
#define HEX_BUF_SIZE (CHECK_BYTES * 2 + 3)

#define ASSERT_INT_EQUAL(result, expect) soft_int_equal(\
    result, \
    expect, \
    #result, \
    #expect, \
    __FILE__, \
    __LINE__\
);

#define ASSERT_INT_CLOSE(result, expect) soft_int_close(\
    result, \
    expect, \
    #result, \
    #expect, \
    __FILE__, \
    __LINE__\
);

#define ASSERT_STR_EQUAL(result, expect) soft_string_equal(\
    result, \
    #result, \
    expect, \
    __FILE__, \
    __LINE__\
);

union pun {
    MyFloat my_float;
    uint64_t bytes;
};

#define ASSERT_BYTES_EQUAL(ex, by) {\
    union pun result;\
    result.bytes = 0;\
    result.my_float = (ex);\
    soft_bytes_equal(result.bytes, by, #ex, __FILE__, __LINE__, 1);\
}

#define ASSERT_BYTES_CLOSE(ex, by) {\
    union pun result;\
    result.bytes = 0;\
    result.my_float = (ex);\
    soft_bytes_equal(result.bytes, by, #ex, __FILE__, __LINE__, 0);\
}

static FILE * log_file = NULL;

static unsigned int failed = 0;
static unsigned int total_tests = 0;

static __attribute__((unused)) void soft_equal(
    int success,
    const char * expr,
    const char * expected,
    const char * file,
    int lineno
)   {
    total_tests++;
    if (log_file == NULL) {
        abort();
    }
    const char * ok;
    if (success) {
        ok = "OK";
    } else {
        ok = "FAIL";
        failed++;
    }
    static const char FORMAT[] = "%4s %16s:%-4d %s should equal %s\n";
    fprintf(log_file, FORMAT, ok, file, lineno, expr, expected);
    if (!success) {
        fprintf(stderr, FORMAT, ok, file, lineno, expr, expected);
    }
}

static __attribute__((unused))  void soft_int_equal(
    int result,
    int expect,
    const char * expr,
    const char * expected,
    const char * file,
    int lineno
) {
    int success = (result == expect);
    soft_equal(success, expr, expected, file, lineno);
    if (!success) {
        failed++;
        fprintf(stderr,
                "%26s got %d expected %d\n",
                "",
                result,
                expect
        );
    }
}

static const int MAX_DIFF = 4;

static __attribute__((unused)) void soft_int_close(
    int result,
    int expect,
    const char * expr,
    const char * expected,
    const char * file,
    int lineno
) {
    int diff = result - expect;
    int success = diff <= MAX_DIFF && diff >= -MAX_DIFF;
    soft_equal(success, expr, expected, file, lineno);
    if (!success) {
        failed++;
        fprintf(stderr,
                "%26s got %d expected %d (plus or minus %d)\n",
                "",
                result,
                expect,
                MAX_DIFF
        );
    }
}

static __attribute__((unused)) void soft_bytes_equal(
    const uint64_t result,
    const uint64_t expect,
    const char * expr,
    const char * file,
    int lineno,
    int exact
) {
    int64_t diff = result - expect;
    int success = 0;
    if (exact) {
        success = diff == 0;
    } else {
        success = diff <= MAX_DIFF && diff >= -MAX_DIFF;
    }
    char hexpected[HEX_BUF_SIZE] = { 0 };
    snprintf(
        hexpected,
        HEX_BUF_SIZE,
        "0x%llx",
        (unsigned long long) expect
    );
    soft_equal(success, expr, hexpected, file, lineno);
    if (!success) {
        failed++;
        if (exact) {
            fprintf(stderr,
                    "%26s got 0x%llx expected %s\n",
                    "",
                    (unsigned long long) result,
                    hexpected
            );
        } else {
            fprintf(stderr,
                    "%26s got 0x%llx expected %s (plus or minus %d)\n",
                    "",
                    (unsigned long long) result,
                    hexpected,
                    MAX_DIFF
            );
        }
    }
}

static __attribute__((unused)) void soft_string_equal(
    const char * result,
    const char * expr,
    const char * expected,
    const char * file,
    int lineno
) {
    int same = (
        result != NULL 
        && expected != NULL 
        && 0 == strcmp(result,expected)
    );
    soft_equal(same, expr, expected, file, lineno);
    if (!same) {
        failed++;
        fprintf(
            stderr,
            "%26s got \"%s\" expected \"%s\"\n",
            "",
            result,
            expected
        );
    }
}


static void setup(const char * name) {
    log_file = fopen(name, "w");
    failed = 0;
    if (log_file == NULL) {
        perror("Couldn't save log!");
        abort();
    }
}
#define BUFSIZE 1024
static void teardown(const char * name) {
    char buffer[BUFSIZE] = {'\0'};
    sprintf(buffer,"Couldn't save log: %s!", name);
    if (fclose(log_file) != 0) {
        perror(buffer);
        abort();
    }
    if (failed == 1) {
        fprintf(
            stderr,
            "There was 1 test failure out of %u (%u%%)\n",
            total_tests,
            failed * 100 / total_tests
        );
        exit(1);
    } else if (failed > 1) {
        fprintf(
            stderr,
            "There were %u test failures out of %u (%u%%)\n",
            failed,
            total_tests,
            failed * 100 / total_tests
        );
        exit(1);
    }
}
